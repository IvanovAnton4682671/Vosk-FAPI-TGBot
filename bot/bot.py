
import os
import requests
from aiogram import Bot, Dispatcher, types
import asyncio
from datetime import datetime
import logging

BACKEND_URL = os.getenv('BACKEND_URL')   #адрес для запросов
BOT_TOKEN = os.getenv('BOT_TOKEN')       #токен бота
bot = Bot(token=BOT_TOKEN)               #объект-бот, с которым взаимодействует пользователь
dp = Dispatcher()                        #объект-диспетчер, который обрабатывает входящие сообщения


@dp.message()                                                                         #декоратор, который обрабатывает все сообщения пользователя
async def echo_message(message: types.Message) -> None:
    """
    Функция эхо-ответа: она получает сообщение пользователя, и если сообщение является голосовым - отправляет запрос с этим аудиосообщением на бэкенд для распознавания,
    и отвечает пользователю на голосовое сообщение текстом из его голосового сообщения.

    Args:
        message (types.Message): Сообщение, отправленное пользователем.
    """
    if message.voice:                                                                 #если сообщение является голосовым
        await message.reply(text='Your audio is being translated. Please, wait...')   #сообщаем о начале обработки аудио
        file_id = message.voice.file_id                                               #получаем id сообщения
        file = await bot.get_file(file_id)                                            #получаем объект-файл
        file_path = file.file_path                                                    #получаем путь к файлу
        file_name = f'{datetime.now().timestamp()}.ogg'                               #создаём уникальное имя для файла с использованием временного штапма
        file_url = f'https://api.telegram.org/file/bot{BOT_TOKEN}/{file_path}'        #формируем URl для скачивания
        response = requests.get(file_url)                                             #скачиваем файл по нашему URL
        with open(file_name, 'wb') as f:                                              #открываем файл для записи в бинарном режиме
            f.write(response.content)                                                 #записываем содержимое скачанного файла
        with open(file_name, 'rb') as f:                                              #открываем файл для чтения в бинарном режиме
            files = {'file': f}                                                       #записываем файл в словарь для передачи в запрос
            response = requests.post(f'{BACKEND_URL}/recognize', files={'file': open(file_name, 'rb')})     #отправляем файл на бэкенд
        os.remove(file_name)                                                          #удаляем локальный файл после отправки
        if response.status_code == 200:                                               #если код хороший
            text = response.json().get('text', 'Не удалось распознать аудио!')        #то получаем текст сообщения или ошибку
            await message.reply(text)                                                 #отвечаем пользователю на его сообщение
        else:                                                                         #иначе
            await message.reply('Ошибка при распознавании аудио!')                    #показываем ошибку
#чтобы не запутаться что тут происходит немного поясню: мы создаём уникальную ссылку на полученный файл и скачиваем его по ней для того,
#чтобы потом этот файл записать в словарь и отправить на бэкенд (скачивание по ссылке через api.telegram более безопасное чем скачивание файла напрямую)
#ещё одно уточнение: может показаться, что тут происходит полная фигня при перезаписывании файлов (типа мы скачали файл, а потом перезаписываем его данные в другой, чзнф?)
#на самом деле при скачивании файла мы получаем не сам файл, а поток данных (бинарных в данном примере с аудиофайлом), и эти данные нужно куда-то записать и сохранить


async def main() -> None:
    """
    Это основная функция, которая постоянно проверяет наличие новых событий для бота.
    """
    logging.basicConfig(level=logging.INFO)   #с этой настройкой в терминале будут отображаться все логи, которые по умолчанию не отображаются, так как имеют более низкий уровень приоритета
    await dp.start_polling(bot)               #опрос Telegram о наличии новых событий для бота bot


if __name__ == '__main__':
    asyncio.run(main())   #запуск бесконечного цикла прослушивания сообщений
